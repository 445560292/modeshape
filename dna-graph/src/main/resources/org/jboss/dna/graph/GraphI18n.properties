#
# JBoss DNA (http://www.jboss.org/dna)
# See the COPYRIGHT.txt file distributed with this work for information
# regarding copyright ownership.  Some portions may be licensed
# to Red Hat, Inc. under one or more contributor license agreements.
# See the AUTHORS.txt file in the distribution for a full listing of 
# individual contributors. 
#
# JBoss DNA is free software. Unless otherwise indicated, all code in JBoss DNA
# is licensed to you under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; either version 2.1 of
# the License, or (at your option) any later version.
#
# JBoss DNA is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this software; if not, write to the Free
# Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
# 02110-1301 USA, or see the FSF site: http://www.fsf.org.
#
closedConnectionMayNotBeUsed = The connection has been closed an may not be used
errorConvertingIo = Error converting {0} to a {1}
errorConvertingType = Error converting {0} to a {1}: {2}
errorReadingPropertyValueBytes = Error reading bytes
invalidIndexInSegmentName = Invalid index, "{0}", in segment name: {1}
invalidQualifiedNameString = Unable to parse qualified name from "{0}"
maximumPoolSizeMayNotBeSmallerThanCorePoolSize = The maximum pool size may not be smaller than the core pool size
missingEndBracketInSegmentName = Missing end bracket in segment name: {0}
noNamespaceRegisteredForPrefix = There is no namespace registered for the prefix "{0}"
pathAncestorDegreeIsInvalid = Unable to obtain the {1} ancestor for {0}
pathCannotBeNormalized = The path {0} is invalid and cannot be normalized
pathIsAlreadyAbsolute = The path {0} is already an absolute path
pathIsNotAbsolute = The path {0} is not an absolute path
pathIsNotRelative = The path {0} is not a relative path
repositoryConnectionPoolIsNotRunning = The repository connection pool is not running
unableToCreateSubpathBeginIndexGreaterThanOrEqualToEndingIndex = Unable to create subpath: fromIndex({0}) >= toIndex({1})
unableToCreateSubpathBeginIndexGreaterThanOrEqualToSize = Unable to create subpath: fromIndex({0}) >= size({1})
unableToCreateValue = Unable to create {0} value from {1} "{2}": undefined type conversion
unableToDiscoverPropertyTypeForNullValue = Unable to discover property type for null value
unableToObtainValidRepositoryAfterAttempts = Unable to obtain a valid repository after {0} attempts
validPathMayNotContainEmptySegment = The path "{0}" is not valid because it contains an empty segment
valueJavaTypeNotCompatibleWithPropertyType = Value is instance of Java type "{0}" and is not compatible with the "{1}" property type
pathExpressionMayNotBeBlank = The path expression may not be blank
pathExpressionIsInvalid = The path expression {0} is not valid
pathExpressionHasInvalidSelect = Invalid select expression "{0}" in the path expression "{1}"
pathExpressionHasInvalidMatch = Invalid match expression "{0}" in the path expression "{1}"
messageDigestNotFound = The "{0}" message digest algorithm could not be found
unableToAccessResourceFileFromClassLoader = Unable to access "{0}" resource from the class loader
pathNotFoundExceptionLowestExistingLocationFound = {0}; lowest existing path is {1}

executingRequest = Executing {0}
executedRequest = Executed {0}
closingRequestProcessor = Closing request processor
closedRequestProcessor = Closed request processor
multipleErrorsWhileExecutingManyRequests = {0} of the many requests resulted in errors: {1}
multipleErrorsWhileExecutingRequests = {0} of the {1} requests resulted in errors: {2}
unsupportedRequestType = Requests of type "{0}" are unsupported; actual request was to {1}
unableToAddMoreRequestsToAlreadyExecutedBatch = Unable to add more requests to a batch of graph requests that has already been executed
unableToCreateReferenceToNodeWithoutUuid = Unable to set a reference to node {0} since it has no UUID
unableToCopyToLocationWithoutAPath = Unable to copy node "{0}" to "{1}" since the desired location has no path
unableToCopyToTheRoot = Unable to copy node "{0}" to "{1}" since the desired location is the root node
actualLocationIsNotSameAsInputLocation = The actual location of {0} is not the same as the current location of {1}
actualLocationIsNotChildOfInputLocation = The actual location of {0} is not a child of the specified location {1}
actualLocationMustHavePath = The actual location of {0} must have a path
actualNewLocationIsNotSameAsInputLocation = The actual new location of {0} is not the same as the input location of {1}
actualNewLocationMustHavePath = The actual new location of {0} must have a path
actualOldLocationIsNotSameAsInputLocation = The actual old location of {0} is not the same as the input location of {1}
actualOldLocationMustHavePath = The actual old location of {0} must have a path
actualNewLocationMustHaveSameParentAsOldLocation = The new location of {0} must be a sibling of the old location of {1}
actualNewLocationMustHaveSameNameAsRequest = The new location of {0} must have the same name as in the request ({1})

errorImportingContent = Error importing {0} content from {1}
unableToFindRepositorySourceWithName = Unable to find a repository source named "{0}"

# In-memory connector
inMemoryNodeDoesNotExist = Could not find an existing node at {0}
errorSerializingInMemoryCachePolicyInSource = Error serializing a {0} instance owned by the {1} in-memory repository
inMemoryConnectorRequestsMustHavePathOrUuid = In-Memory connector can only process requests with a path and/or UUID
workspaceDoesNotExistInRepository = The workspace "{0}" does not exist in the "{1}" in-memory repository
workspaceAlreadyExistsInRepository = The workspace "{0}" already exists in the "{1}" in-memory repository

# Federation connector
namePropertyIsRequiredForFederatedRepositorySource = The "{0}" property is required on each federated repository source
propertyIsRequiredForFederatedRepositorySource = The "{0}" property is required on the "{1}" federated repository source
federatedRepositorySourceMustBeInitialized = The "{0}" federated repository source must be initialized before it can be used
errorReadingConfigurationForFederatedRepositorySource = Error with the "{0}" federated repository source's configuration at "{3}" in the "{2}" workspace of "{1}"
errorAddingProjectionRuleParseMethod = Error while adding a parsing method for a federation projection rule
requiredNodeDoesNotExistRelativeToNode = The required node "{0}" does not exist relative to "{1}" in "{2}" workspace of the "{3}" repository
unableToObtainConnectionToFederatedSource = Unable to obtain a connection to source "{0}" being federated by the "{1}" workspace of the "{2}" federated repository
workspaceDoesNotExistInFederatedRepository = The workspace "{0}" does not exist in the "{1}" federated repository
locationCannotBeProjectedIntoWorkspaceAndSource = {0} does not exist in the "{1}" workspace of the "{2}" federated repository
unableToAddRequestToChannelThatIsDone = Unable to add a request to the "{0}" channel since it is done: {1}
federatedSourceDoesNotSupportCreatingWorkspaces = {0} is a source that does not allow creating workspaces
federatedSourceDoesNotSupportCloningWorkspaces = {0} is a source that does not allow cloning workspaces
federatedSourceDoesNotSupportDestroyingWorkspaces = {0} is a source that does not allow destroying workspaces
unableToProjectSourceInformationIntoWorkspace = Unable to project source information at {0} in the "{1} federated repository source using projection {2}
unableToCreateNodeUnderPlaceholder = Unable to create node "{0}" under {1} in the "{2}" workspace of the "{3}" federarted repository because the parent is a placeholder
unableToUpdatePlaceholder = Unable to update node {0} in the "{1}" workspace of the "{2}" federarted repository because the node is a placeholder
unableToDeletePlaceholder = Unable to delete node {0} in the "{1}" workspace of the "{2}" federarted repository because the node is a placeholder
copyLimitedToBeWithinSingleSource = Unable to copy {0} in the "{1}" workspace of the "{3}" federarted repository into {2} in the "{3}" workspace: copy is only supported when the original and new locations are within the same source
moveLimitedToBeWithinSingleSource = Unable to move {0} in the "{1}" workspace of the "{3}" federarted repository into {2} in the "{3}" workspace: move is only supported when the original and new locations are within the same source
