<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ JBoss DNA (http://www.jboss.org/dna)
  ~
  ~ See the COPYRIGHT.txt file distributed with this work for information
  ~ regarding copyright ownership.  Some portions may be licensed
  ~ to Red Hat, Inc. under one or more contributor license agreements.
  ~ See the AUTHORS.txt file in the distribution for a full listing of 
  ~ individual contributors.
  ~
  ~ JBoss DNA is free software. Unless otherwise indicated, all code in JBoss DNA
  ~ is licensed to you under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ JBoss DNA is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE preface PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd"	[
<!ENTITY % CustomDTD SYSTEM "../custom.dtd">
%CustomDTD;
]>
<chapter id="environment">
  <title>Environment</title>
  <para>
		The various components of JBoss DNA are designed as plain old Java objects, or POJOs.  And rather than making assumptions
		about their environment, each component instead requires that any external dependencies necessary for it to operate
		must be supplied to it.  This pattern is known as Dependency Injection, and it allows the components to be simpler
		and allows for a great deal of flexibility and customization in how the components are configured.  
		And, JBoss DNA will soon provide a higher-level component that leverages the 
		<ulink url="http://www.jboss.org/jbossmc">JBoss Microcontainer</ulink> to automatically assemble and wire together
		all the lower-level components.
  </para>
	<sect1 id="execution-context">
		<title>Execution contexts</title>
		<para>
			One of the objects that must be supplied to many JBoss DNA components is an &ExecutionContext;.  Some components 
			require this context to be passed into individual methods, allowing the context to vary with each method invocation.
			Other components require the context to be provided before it's used, and will use that context for all its operations
			(until it is given a different one).
		</para>
		<para>
			What does an &ExecutionContext; represent?  Quite simply, it's the set of objects that define the environment
			or context in which the method or component is currently operating.  It includes a way for recording and reporting 
			errors and problems.  It includes the ability to <link linkend="classloaders">create class loaders</link> 
			given a classpath of class loader names. It also includes information about the current <link linkend="security">user</link>.
			It includes access to factories that can be used to create and convert property values. And it includes factories 
			for working with namespaces and fully-qualified names.  In fact, as JBoss DNA evolves, more things may need to be
			added.  Here is what the &ExecutionContext; interface looks like:
		</para>
	  <programlisting>
public class &ExecutionContext; implements &ClassLoaderFactory; {

    /**
     * Get the factories that should be used to create values for {@link Property properties}.
     * @return the property value factory; never null
     */
    public &ValueFactories; getValueFactories() {...}

    /**
     * Get the namespace registry for this context.
     * @return the namespace registry; never null
     */
    public &NamespaceRegistry; getNamespaceRegistry() {...}

    /**
     * Get the factory for creating {@link Property} objects.
     * @return the property factory; never null
     */
    public &PropertyFactory; getPropertyFactory() {...}

    /**
     * Get the security context for this environment.
     * @return the security context; never <code>null</code>
     */
    public &SecurityContext; getSecurityContext() {...}

    /**
     * Get the JAAS subject for which this context was created.
     * @return the subject; never null
     */
    public &Subject; getSubject() {...}

    /**
     * Return a logger associated with this context. This logger records only those activities within the 
     * context and provide a way to capture the context-specific activities. All log messages are also
     * sent to the system logger, so classes that log via this mechanism should <i>not</i> also 
     * {@link Logger#getLogger(Class) obtain a system logger}.
     * @param clazz the class that is doing the logging
     * @return the logger, named after <code>clazz</code>; never null
     */
    public &Logger; getLogger( Class&lt;?> clazz ) {...}

    /**
    * Return a logger associated with this context. This logger records only those activities within the 
    * context and provide a way to capture the context-specific activities. All log messages are also
    * sent to the system logger, so classes that log via this mechanism should <i>not</i> also 
    * {@link Logger#getLogger(Class) obtain a system logger}.
     * @param name the name for the logger
     * @return the logger, named after <code>clazz</code>; never null
     */
    public &Logger; getLogger( String name ) {...}

		...
}
</programlisting>
		<para>
			Notice that &ExecutionContext; implements the &ClassLoaderFactory; interface described in the
			<link linkend="classloaders">previous chapter</link>, meaning it can be used to create other contexts.  These other methods are not shown,
			but can be used to create create subcontexts with different <link linkend="security">security contexts</link>,
	    with different namespace registry, or with different combinations of components.
		</para>
	  <para>
			The fact that so many of the JBoss DNA components take &ExecutionContext; instances gives us some interesting possibilities.  
			For example, one execution context instance can be used as the highest-level (or "application-level") context for all of the services 
			(e.g., &RepositoryService;, &SequencingService;, etc.).
			Then, an execution context could be created for each user that will be performing operations, and that user's context can
			be passed around to not only provide security information about the user but also to allow the activities being performed
			to be recorded for user feedback, monitoring and/or auditing purposes.
		</para>
		<para>
			The following code fragment shows how easy it is to create various execution contexts:
		</para>
	  <programlisting>
&ExecutionContext; context1 = new &ExecutionContext;();

// Create a context for a user, authenticating using JAAS ...
&LoginContext; loginContext = new LoginContext("username",callbackHandler);
&ExecutionContext; context2 = context1.with(new LoginContext("username"));

// Create a context for the same user, authenticating using JAAS, and using a different callback handler ...
&CallbackHandler; callbackHandler = ...
&LoginContext; loginContext = new LoginContext("username",callbackHandler);
&ExecutionContext; context3 = context1.with(loginContext);

// Create a context that uses a provided &SecurityContext; (see the <link linkend="security">next section</link>)...
&SecurityContext; mySecurityContext = ...
&ExecutionContext; context4 = context1.with(mySecurityContext);
</programlisting>
		<para>
			These contexts can then be passed to the various components as needed.
		</para>
	</sect1>
	<sect1 id="security">
		<title>Security</title>
	  <para>
	    JBoss DNA uses a simple abstraction layer to isolate it from the security infrastructure used within an application.
	   The &SecurityContext; interface is defined as follows:
		</para>
	  <programlisting>
public interface &SecurityContext; {

    /**
     * Get the name of the authenticated user.
     * @return the authenticated user's name
     */
    &String; getUserName();

    /**
     * Determine whether the authenticated user has the given role.
     * @param roleName the name of the role to check
     * @return true if the user has the role and is logged in; false otherwise
     */
    boolean hasRole( String roleName );

    /**
     * Logs the user out of the authentication mechanism.
     * For some authentication mechanisms, this will be implemented as a no-op.
     */
    void logout();
}
</programlisting>
		<para>
			As noted below, this security context is made available through the &ExecutionContext; described above.
		</para>
		<sect1 id="jaas_security">
			<title>JAAS</title>
			<para>
				One such implementation is the &JaasSecurityContext;, which delegates any authentication or authorization requests to a
		    <ulink url="http://java.sun.com/javase/technologies/security/">Java Authentication and Authorization Service (JAAS)</ulink>
		    provider.  This is the standard approach for authenticating and authorizing in Java, and is the default mechanism 
		    used by the &JcrEngine;.  
		  </para>
		  <para>
				There are quite a few JAAS providers available, but one of the best and most powerful providers is
		    <ulink url="http://www.jboss.org/jbosssecurity/">JBoss Security</ulink>, which is the open source
				security framework used by JBoss.  JBoss Security offers a number of JAAS login modules, including:
		    <itemizedlist>
		      <listitem>
		        <para>
		          <emphasis role="strong">User-Roles Login Module</emphasis>
		          is a simple
		          <code>javax.security.auth.login.LoginContext</code>
		          implementation that uses usernames and passwords stored in a properties file.
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          <emphasis role="strong">Client Login Module</emphasis>
		          prompts the user for their username and password.
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          <emphasis role="strong">Database Server Login Module</emphasis>
		          uses a JDBC database to authenticate principals and associate them with roles.
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          <emphasis role="strong">LDAP Login Module</emphasis>
		          uses an LDAP directory to authenticate principals. Two implementations are available.
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          <emphasis role="strong">Certificate Login Module</emphasis>
		          authenticates using X509 certificates, obtaining roles from either property files or a JDBC database.
		        </para>
		      </listitem>
		      <listitem>
		        <para>
		          <emphasis role="strong">Operating System Login Module</emphasis>
		          authenticates using the operating system's mechanism.
		        </para>
		      </listitem>
		    </itemizedlist>
		    and many others.  Plus, JBoss Security also provides other capabilities, such as using XACML policies or using federated single sign-on. 
				For more detail, see the <ulink url="http://www.jboss.org/jbosssecurity/">JBoss Security</ulink> project.
		  </para>
		</sect2>
		<sect2 id="web_security">
			<title>Web application security</title>
			<para>
				If JBoss DNA is being used within a web application, then it is probably desirable to reuse the security infrastructure
				of the application server.  This can be accomplished by implementing the &SecurityContext; interface with an implementation
				that delegates to the <interface>HttpServletRequest</interface>.  Then, for each request, create a &SecurityContextCredentials;
				instance around your &SecurityContext;, and use that credentials to obtain a JCR &Session;.
			</para>
			<para>
				Here is an example of the &SecurityContext; implementation that uses the servlet request:
			</para>
	  <programlisting>
@Immutable
public class ServletSecurityContext implements &SecurityContext; {

    private final String userName;
    private final HttpServletRequest request;

    /**
     * Create a {@link ServletSecurityContext} with the supplied {@link HttpServletRequest servlet information}.
     * 
     * @param request the servlet request; may not be null
     */
    public ServletSecurityContext( HttpServletRequest request ) {
        this.request = request;
        this.userName = request.getUserPrincipal() != null ? request.getUserPrincipal().getName() : null;
    }

    /**
     * Get the name of the authenticated user.
     * @return the authenticated user's name
     */
    public &String; getUserName() {
			return userName;
		}

    /**
     * Determine whether the authenticated user has the given role.
     * @param roleName the name of the role to check
     * @return true if the user has the role and is logged in; false otherwise
     */
    boolean hasRole( String roleName ) {
			request.isUserInRole(roleName);
		}

    /**
     * Logs the user out of the authentication mechanism.
     * For some authentication mechanisms, this will be implemented as a no-op.
     */
    public void logout() {
		}
}</programlisting>
			<para>
				Then use this to create a &Session;:
			</para>
	  <programlisting>
HttpServletRequest request = ...
&Repository; repository = engine.getRepository("my repository");
&SecurityContext; securityContext = new ServletSecurityContext(httpServletRequest);
SecurityContextCredentials credentials = new SecurityContextCredentials(securityContext);
&Session; session = repository.login(credentials, workspaceName);
</programlisting>
		</sect2>
	</sect1>
	<sect1>
		<title>Summary</title>
		<para>
			In this chapter, we covered security and environment topics as used throughout JBoss DNA. 
			The <link linkend="repositories">next chapter</link> will cover JBoss DNA repositories, including the connector framework,
			how DNA's JCR implementation works with connectors, what connectors are available (and how to use them),
			and how to write your own connector.
		</para>
	</sect1>
</chapter>

