<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ JBoss, Home of Professional Open Source.
  ~
  ~ Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  ~ indicated by the @author tags or express copyright attribution
  ~ statements applied by the authors.  All third-party contributions are
  ~ distributed under license by Red Hat Middleware LLC.
  ~
  ~ This copyrighted material is made available to anyone wishing to use, modify,
  ~ copy, or redistribute it subject to the terms and conditions of the GNU
  ~ Lesser General Public License, as published by the Free Software Foundation.
  ~
  ~ This program is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="custom_sequencers">
  <title>Creating custom sequencers</title>
  <para>The current release of JBoss DNA comes with two sequencers: one that extracts metadata from a variety of image file formats,
  and another that extracts some of the ID3 metadata from MP3 audio files.  However, it's very easy to create your own
  sequencers and to then configure JBoss DNA to use them in your own application.
  </para>
  <para>
  Creating a custom sequencer involves the following steps:
  <itemizedlist>
    <listitem>
      <para>Create a Maven 2 project for your sequencer;</para>
    </listitem>
    <listitem>
      <para>Implement the <code>org.jboss.dna.spi.sequencers.StreamSequencer</code> interface with your own implementation, and create unit tests to verify
      the functionality and expected behavior;</para>
    </listitem>
    <listitem>
      <para>Add the sequencer configuration to the JBoss DNA <code>SequencingService</code> in your application
      as described in the <link linkend="using_dna">previous chapter</link>; and</para>
    </listitem>
    <listitem>
      <para>Deploy the JAR file with your implementation (as well as any dependencies), and make them available to JBoss DNA
      in your application.</para>
    </listitem>
  </itemizedlist>
  It's that simple.
  </para>
  <sect1 id="custom_sequencer_project">
    <title>Creating the Maven 2 project</title>
    <para>The first step is to create the Maven 2 project that you can use to compile your code and build the JARs.
    Maven 2 automates a lot of the work, and since you're already <link linkend="downloading_and_running">set up to use Maven</link>,
    using Maven for your project will save you a lot of time and effort.  Of course, you don't have to use Maven 2, but then you'll
    have to get the required libraries and manage the compiling and building process yourself.</para>
    <note>
      <para>JBoss DNA may provide in the future a Maven archetype for creating sequencer projects.  If you'd find this useful
        and would like to help create it, please <link linkend="preface">join the community</link>.</para>
    </note>
  <note>
    <para>The <code>dna-sequencer-images</code> project is a small, self-contained sequencer implementation that
    has only the minimal dependencies.  Starting with this project's source and modifying it to suit your needs may be the easiest way to get started.
    See the subversion repository: <ulink url="http://anonsvn.jboss.org/repos/dna/trunk/extensions/dna-sequencer-images/">http://anonsvn.jboss.org/repos/dna/trunk/sequencers/dna-sequencer-images/</ulink>
    </para>
  </note>
    <para>You can create your Maven project any way you'd like.  For examples, see the <ulink url="http://maven.apache.org/guides/getting-started/index.html#How_do_I_make_my_first_Maven_project">Maven 2 documentation</ulink>.  
    Once you've done that, just add the dependencies in your project's <code>pom.xml</code> dependencies section:</para>
  	<programlisting role="XML"><![CDATA[
<dependency>
  <groupId>org.jboss.dna</groupId>
  <artifactId>dna-common</artifactId>
  <version>0.1</version>
</dependency>
<dependency>
  <groupId>org.jboss.dna</groupId>
  <artifactId>dna-spi</artifactId>
  <version>0.1</version>
</dependency>
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-api</artifactId>
</dependency>
 ]]></programlisting>
		<para>These are minimum dependencies required for compiling a sequencer.  Of course, you'll have to add
  		other dependencies that your sequencer needs.</para>
  	<para>As for testing, you probably will want to add more dependencies, such as those listed here:</para>
		<programlisting role="XML"><![CDATA[
<dependency>
  <groupId>junit</groupId>
  <artifactId>junit</artifactId>
  <version>4.4</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>org.hamcrest</groupId>
  <artifactId>hamcrest-library</artifactId>
  <version>1.1</version>
  <scope>test</scope>
</dependency>
<!-- Logging with Log4J -->
<dependency>
  <groupId>org.slf4j</groupId>
  <artifactId>slf4j-log4j12</artifactId>
  <version>1.4.3</version>
  <scope>test</scope>
</dependency>
<dependency>
  <groupId>log4j</groupId>
  <artifactId>log4j</artifactId>
  <version>1.2.14</version>
  <scope>test</scope>
</dependency>
 ]]></programlisting>
  	<para>Testing JBoss DNA sequencers does not require a JCR repository or the JBoss DNA services.  (For more detail,
  		see the <link linkend="testing_custom_sequencers">testing section</link>.)  However, if you want to do
  		integration testing with a JCR repository and the JBoss DNA services, you'll need additional dependencies for these libraries.</para>
		<programlisting role="XML"><![CDATA[
<dependency>
  <groupId>org.jboss.dna</groupId>
  <artifactId>dna-repository</artifactId>
  <version>0.1</version>
  <scope>test</scope>
</dependency>
<!-- Java Content Repository API -->
<dependency>
  <groupId>javax.jcr</groupId>
  <artifactId>jcr</artifactId>
  <version>1.0.1</version>
  <scope>test</scope>
</dependency>
<!-- Apache Jackrabbit (JCR Implementation) -->
<dependency>
  <groupId>org.apache.jackrabbit</groupId>
  <artifactId>jackrabbit-api</artifactId>
  <version>1.3.3</version>
  <scope>test</scope>
  <!-- Exclude these since they are included in JDK 1.5 -->
  <exclusions>
    <exclusion>
      <groupId>xml-apis</groupId>
      <artifactId>xml-apis</artifactId>
    </exclusion>
    <exclusion>
      <groupId>xerces</groupId>
      <artifactId>xercesImpl</artifactId>
    </exclusion>
  </exclusions>
</dependency>
<dependency>
  <groupId>org.apache.jackrabbit</groupId>
  <artifactId>jackrabbit-core</artifactId>
  <version>1.3.3</version>
  <scope>test</scope>
  <!-- Exclude these since they are included in JDK 1.5 -->
  <exclusions>
    <exclusion>
      <groupId>xml-apis</groupId>
      <artifactId>xml-apis</artifactId>
    </exclusion>
    <exclusion>
      <groupId>xerces</groupId>
      <artifactId>xercesImpl</artifactId>
    </exclusion>
  </exclusions>
</dependency>
 ]]></programlisting>
  <para>At this point, your project should be set up correctly, and you're ready to move on to 
  	<link linkend="custom_sequencer_implementation">writing the Java implementation</link> for your sequencer.</para>
  </sect1>
  <sect1 id="custom_sequencer_implementation">
    <title>Implementing the StreamSequencer interface</title>
    <para>After creating the project and setting up the dependencies, the next step is to create a Java class that implements
    	the <code>org.jboss.dna.spi.sequencers.StreamSequencer</code> interface.  This interface is very straightforward
    	and involves a single method:</para>
    <programlisting role="JAVA"><![CDATA[
public interface StreamSequencer {

    /**
     * Sequence the data found in the supplied stream, placing the output 
     * information into the supplied map.
     *
     * @param stream the stream with the data to be sequenced; never null
     * @param output the output from the sequencing operation; never null
     * @param progressMonitor the progress monitor that should be kept 
     *   updated with the sequencer's progress and that should be
     *   frequently consulted as to whether this operation has been cancelled.
     */
    void sequence( InputStream stream, SequencerOutput output, ProgressMonitor progressMonitor );
 ]]></programlisting>
    <para>The job of a stream sequencer is to process the data in the supplied stream, and place into the <code>SequencerOutput</code> 
    any information that is to go into the JCR repository.  JBoss DNA figures out when your sequencer should be called
    (of course, using the sequencing configuration you'll add in a bit), and then makes sure the generated information
    is saved in the correct place in the repository.  
    </para>
    <para>The <code>SequencerOutput</code> class is fairly easy to use.  There are basically two methods you need to call.
    One method sets the property values, while the other sets references to other nodes in the repository.  Use these
    methods to describe the properties of the nodes you want to create, using relative paths for the nodes and
    valid JCR property names for properties and references.  JBoss DNA will ensure that nodes are created or updated
    whenever they're needed.</para>
    <programlisting role="JAVA"><![CDATA[
public interface SequencerOutput {

  /**
   * Set the supplied property on the supplied node.  The allowable
   * values are any of the following:
   *   - primitives (which will be autoboxed)
   *   - String instances
   *   - String arrays
   *   - byte arrays
   *   - InputStream instances
   *   - Calendar instances
   *
   * @param nodePath the path to the node containing the property; 
   * may not be null
   * @param property the name of the property to be set
   * @param values the value(s) for the property; may be empty if 
   * any existing property is to be removed
   */
  void setProperty( String nodePath, String property, Object... values );

  /**
   * Set the supplied reference on the supplied node.
   *
   * @param nodePath the path to the node containing the property; 
   * may not be null
   * @param property the name of the property to be set
   * @param paths the paths to the referenced property, which may be
   * absolute paths or relative to the sequencer output node;
   * may be empty if any existing property is to be removed
   */
  void setReference( String nodePath, String property, String... paths );
}
 ]]></programlisting>
    <para>JBoss DNA will create nodes of type <code>nt:unstructured</code> unless you specify the value for the
      <code>jcr:primaryType</code> property.  You can also specify the values for the <code>jcr:mixinTypes</code> property
      if you want to add mixins to any node.</para>
    <para>For a complete example of a sequencer, let's look at the <code>org.jboss.dna.sequencers.image.ImageMetadataSequencer</code> 
			implementation:</para>
    <programlisting role="JAVA"><![CDATA[
public class ImageMetadataSequencer implements StreamSequencer {

    public static final String METADATA_NODE = "image:metadata";
    public static final String IMAGE_PRIMARY_TYPE = "jcr:primaryType";
    public static final String IMAGE_MIXINS = "jcr:mixinTypes";
    public static final String IMAGE_MIME_TYPE = "jcr:mimeType";
    public static final String IMAGE_ENCODING = "jcr:encoding";
    public static final String IMAGE_FORMAT_NAME = "image:formatName";
    public static final String IMAGE_WIDTH = "image:width";
    public static final String IMAGE_HEIGHT = "image:height";
    public static final String IMAGE_BITS_PER_PIXEL = "image:bitsPerPixel";
    public static final String IMAGE_PROGRESSIVE = "image:progressive";
    public static final String IMAGE_NUMBER_OF_IMAGES = "image:numberOfImages";
    public static final String IMAGE_PHYSICAL_WIDTH_DPI = "image:physicalWidthDpi";
    public static final String IMAGE_PHYSICAL_HEIGHT_DPI = "image:physicalHeightDpi";
    public static final String IMAGE_PHYSICAL_WIDTH_INCHES = "image:physicalWidthInches";
    public static final String IMAGE_PHYSICAL_HEIGHT_INCHES = "image:physicalHeightInches";

    /**
     * {@inheritDoc}
     */
    public void sequence( InputStream stream, SequencerOutput output, 
                          ProgressMonitor progressMonitor ) {
        progressMonitor.beginTask(10, ImageSequencerI18n.sequencerTaskName);

        ImageMetadata metadata = new ImageMetadata();
        metadata.setInput(stream);
        metadata.setDetermineImageNumber(true);
        metadata.setCollectComments(true);

        // Process the image stream and extract the metadata ...
        if (!metadata.check()) {
            metadata = null;
        }
        progressMonitor.worked(5);
        if (progressMonitor.isCancelled()) return;

        // Generate the output graph if we found useful metadata ...
        if (metadata != null) {
            // Place the image metadata into the output map ...
            output.setProperty(METADATA_NODE, IMAGE_PRIMARY_TYPE, "image:metadata");
            // output.psetProperty(METADATA_NODE, IMAGE_MIXINS, "");
            output.setProperty(METADATA_NODE, IMAGE_MIME_TYPE, metadata.getMimeType());
            // output.setProperty(METADATA_NODE, IMAGE_ENCODING, "");
            output.setProperty(METADATA_NODE, IMAGE_FORMAT_NAME, metadata.getFormatName());
            output.setProperty(METADATA_NODE, IMAGE_WIDTH, metadata.getWidth());
            output.setProperty(METADATA_NODE, IMAGE_HEIGHT, metadata.getHeight());
            output.setProperty(METADATA_NODE, IMAGE_BITS_PER_PIXEL, metadata.getBitsPerPixel());
            output.setProperty(METADATA_NODE, IMAGE_PROGRESSIVE, metadata.isProgressive());
            output.setProperty(METADATA_NODE, IMAGE_NUMBER_OF_IMAGES, metadata.getNumberOfImages());
            output.setProperty(METADATA_NODE, IMAGE_PHYSICAL_WIDTH_DPI, metadata.getPhysicalWidthDpi());
            output.setProperty(METADATA_NODE, IMAGE_PHYSICAL_HEIGHT_DPI, metadata.getPhysicalHeightDpi());
            output.setProperty(METADATA_NODE, IMAGE_PHYSICAL_WIDTH_INCHES, metadata.getPhysicalWidthInch());
            output.setProperty(METADATA_NODE, IMAGE_PHYSICAL_HEIGHT_INCHES, metadata.getPhysicalHeightInch());
        }

        progressMonitor.done();
    }
}
 ]]></programlisting>
    <para>
    Notice how the image metadata is extracted and the output graph is generated.  A single node is created with the name <code>image:metadata</code>
    and with the <code>image:metadata</code> node type.  No mixins are defined for the node, but several properties are set on the node
    using the values obtained from the image metadata.  After this method returns, the constructed graph will be saved to the repository
    in all of the places defined by its configuration.  (This is why only relative paths are used in the sequencer.)
    </para>
    <para>Also note how the progress monitor is used.  Reporting progress through the supplied <code>ProgressMonitor</code> is very easy, and it ensures that JBoss DNA
     can accurately monitor and report the status of sequencing activities to the users.  At the beginning of the operation, call
     <code>beginTask(...)</code> with a meaningful message describing
     the operation and a total for the amount of work that will be done by this sequencer. Then perform the sequencing work,
     periodically reporting work by specifying the incremental amount of work with the <code>worked(double)</code> method, or
     by creating a subtask with the <code>createSubtask(double)</code> method and reporting work against that subtask
     monitor.
     </para>
     <para>Your method should periodically use the ProgressMonitor's <code>isCancelled()</code> method to check whether the operation has been
     cancelled.. If this method returns true, the implementation should abort all work as
     soon as possible and close any resources that were acquired or opened.
     </para>
     <para>
     Finally, when your sequencing operation is completed, it should call <code>done()</code> on the progress monitor.
     </para>
  </sect1>
  <sect1 id="testing_custom_sequencers">
    <title>Testing custom sequencers</title>
    <para>The sequencing framework was designed to make testing sequencers much easier.  In particular, the
    <code>StreamSequencer</code> interface does not make use of the JCR API.  So instead of requiring a fully-configured
    JCR repository and JBoss DNA system, unit tests for a sequencer can focus on testing that the content is
    processed correctly and the desired output graph is generated.</para>
    <note>
      <para>For a complete example of a sequencer unit test, see the <code>ImageMetadataSequencerTest</code> unit test
      in the <code>org.jboss.dna.sequencer.images</code> package of the <code>dna-sequencers-image</code> project.
      </para>
    </note>
    <para>The following code fragment shows one way of testing a sequencer, using JUnit 4.4 assertions and 
      some of the classes made available by JBoss DNA.  Of course,
      this example code does not do any error handling and does not make all the assertions a real test would.</para>
    <programlisting role="JAVA"><![CDATA[
Sequencer sequencer = new ImageMetadataSequencer();
MockSequencerOutput output = new MockSequencerOutput();
ProgressMonitor progress = new SimpleProgressMonitor("Test activity");
InputStream stream = null;
try {
    stream = this.getClass().getClassLoader().getResource("caution.gif").openStream();
    sequencer.sequence(stream,output,progress);   // writes to 'output'
    assertThat(output.getPropertyValues("image:metadata", "jcr:primaryType"), 
               is(new Object[] {"image:metadata"}));
    assertThat(output.getPropertyValues("image:metadata", "jcr:mimeType"), 
               is(new Object[] {"image/gif"}));
    // ... make more assertions here
    assertThat(output.hasReferences(), is(false));
} finally {
    stream.close();
}
 ]]></programlisting>
  <para>It's also useful to test that a sequencer produces no output for something it should not understand:</para>
    <programlisting role="JAVA"><![CDATA[
Sequencer sequencer = new ImageMetadataSequencer();
MockSequencerOutput output = new MockSequencerOutput();
ProgressMonitor progress = new SimpleProgressMonitor("Test activity");
InputStream stream = null;
try {
    stream = this.getClass().getClassLoader().getResource("caution.pict").openStream();
    sequencer.sequence(stream,output,progress);   // writes to 'output'
    assertThat(output.hasProperties(), is(false));
    assertThat(output.hasReferences(), is(false));
} finally {
    stream.close();
}
 ]]></programlisting>
    <para>These are just two simple tests that show ways of testing a sequencer.  Some tests may get quite involved,
    especially if a lot of output data is produced.  
    </para>
    <para>It may also be useful to create some integration tests
    that <link linkend="using_dna">configure JBoss DNA</link> to use a custom sequencer, and to then upload
    content using the JCR API, verifying that the custom sequencer did run.  However, remember that JBoss DNA
    runs sequencers asynchronously in the background, and you must sychronize your tests to ensure that the
    sequencers have a chance to run before checking the results.  (One way of doing this (although, granted, not always reliable) is to wait for a second
    after uploading your content, shutdown the <code>SequencingService</code> and await its termination,
    and then check that the sequencer output has been saved to the JCR repository.  For an example of this technique,
    see the <code>SequencingClientTest</code> unit test in the example application.)
    </para>  
  </sect1>
  <sect1 id="deploying_custom_sequencers">
    <title>Deploying custom sequencers</title>
    <para>The first step of deploying a sequencer consists of adding/changing the sequencer configuration (e.g., <code>SequencerConfig</code>)
    in the <code>SequencingService</code>.  This was covered in the <link linkend="sequencing_service">previous chapter</link>.
    </para>
    <para>
    The second step is to make the sequencer implementation available to JBoss DNA.  At this time, the JAR containing 
    your new sequencer, as well as any JARs that your sequencer depends on, should be placed on your application classpath.</para>
    <note>
      <para>A future goal of JBoss DNA is to allow sequencers, connectors, and other extensions to be easily deployed into
        a runtime repository.  This process will not only be much simpler, but it will also provide JBoss DNA 
        with the information necessary to update configurations and create the appropriate class loaders for each extension.
        Having separate class loaders for each extension helps prevent the pollution of the common classpath, 
        facilitates an isolated runtime environment to eliminate any dependency conflicts, and may potentially
        enable hot redeployment of newer extension versions.
      </para>
    </note>
  </sect1>
</chapter>
