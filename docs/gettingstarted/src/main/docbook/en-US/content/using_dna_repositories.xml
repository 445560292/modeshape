<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ JBoss DNA (http://www.jboss.org/dna)
  ~
  ~ See the COPYRIGHT.txt file distributed with this work for information
  ~ regarding copyright ownership.  Some portions may be licensed
  ~ to Red Hat, Inc. under one or more contributor license agreements.
  ~ See the AUTHORS.txt file in the distribution for a full listing of 
  ~ individual contributors.
  ~
  ~ JBoss DNA is free software. Unless otherwise indicated, all code in JBoss DNA
  ~ is licensed to you under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ JBoss DNA is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="using_dna_repositories">
	<title>Using JBoss DNA Repositories</title>
	<para>One of the capabilities of JBoss DNA is to provide access through 
		<ulink url="http://www.jcp.org/en/jsr/detail?id=170">JCR</ulink> to different kinds of repositories and storage systems.
		Your applications work with the JCR API, but through JBoss DNA you're able to accesses the content from where the information
		exists - not just a single purpose-built repository.  This is fundamentally what makes JBoss DNA different.</para>
	<para>How does JBoss DNA do this?  At the heart of JBoss DNA and it's JCR implementation is a simple connector
		system that is designed around creating and accessing graphs.  The JBoss DNA JCR implementation actually just sits on
		top of a single repository source, which it uses to access of the repositories content.
		<figure id="dnajcr-and-connector">
			<title>JBoss DNA's JCR implementation delegates to a repository source</title>
			<graphic align="center" scale="100" fileref="dnajcr-and-connector.png"/>
		</figure>
		That single repository source could be an in-memory repository, a JBoss Cache instance, or a federated repository.
		<figure id="dna-connectors-0.2">
			<title>JBoss DNA can put JCR on top of multiple kinds of systems</title>
			<graphic align="center" scale="100" fileref="dna-connectors-0.2.png"/>
		</figure>
  	And the JBoss DNA project has plans to create other connectors, too.  For instance, we're going to build a connector 
    to other JCR repositories.  And another to a file system, so that the files and directories on an area of the file system
    can be accessed through JCR.  Of course, if we don't have a connector to suit your needs, you can write your own.
		<figure id="dna-connectors-future">
			<title>Future JBoss DNA connectors</title>
			<graphic align="center" scale="100" fileref="dna-connectors-future.png"/>
		</figure>
	</para>
	<note>
		<para>You might be thinking that these connectors are interesting, but what do they really provide?  Is it really useful
		  to use JCR to access a relational database rather than JDBC?  Or, why access the files on a file system when there 
		  are already mechanisms to do that?</para>
	  <para>Maybe putting JCR on top of a single system (like a JDBC database) isn't that interesting. What
		  <emphasis>is</emphasis> interesting, though, is accessing the information in multiple systems <emphasis>as if all that information were
		  in a single JCR repository</emphasis>.  That's what the federated repository source is all about.  The JBoss DNA connector
			system just makes it possible to interact with all these systems in the same way.</para>
		<para>Think of it this way: with JBoss DNA, you can use JCR to get to the schemas of multiple relational databases <emphasis>and</emphasis> the schemas
		  defined by DDL files in your SVN repository <emphasis>and</emphasis> the schemas defined by logical models stored on your file system.
		</para>
	</note>
	<para>So with this very high-level summary, let's dive a little deeper and look at how to configure and use JBoss DNA and JCR.</para>
	<sect1 id="repository_service">
		<title>Configuring the Repository Service</title>
		<para>The JBoss DNA <emphasis>repository service</emphasis> is the component that manages the <emphasis>repositories</emphasis>
		  and connections to them.  The service reads its configuration from a <code>RepositorySource</code> instance (i.e., the
		  "configuration repository") and automatically sets up the repositories given the <code>RepositorySource</code> instances
		  found in the configuration repository.</para>
		<note>
			<para>Configuring JBoss DNA services is more manual and complex than we want. As you'll see, JBoss DNA uses dependency
	      injection to allow a great deal of flexibility in how it can be configured and customized. But this flexibility
	      makes it more difficult for you to use.  We understand this, and will soon provide a much easier way to set up 
				and manage JBoss DNA.  Current plans are to use the <ulink url="http://www.jboss.org/jbossmc">JBoss Microcontainer</ulink>
				along with a configuration repository that makes it very easy to set up and manage JBoss DNA, whether it's used in
				a simple application or a cluster of processes.</para>
		</note>
		<para>To set up the repository service, we need to first set up a few other objects:
			<itemizedlist>
				<listitem>
					<para>A <emphasis>factory for execution contexts</emphasis>.  Execution contexts define the context (or environment) 
					    in which the service runs and in which operations against repositories are performed.  <code>ExecutionContext</code>
					    instances can be created using JAAS application contexts, meaning that they contain the information about the subject
					    that the software represents.  Execution contexts also provide access to the all of the factories and utilities
					    used throughout the services and components, and it is through this mechanism that you can inject your own behavior.
							For example, if your application already had a notion of namespaces, you could override the execution context's
							<code>NamespaceRegistry</code> to use the namespaces defined in your application.</para>
				</listitem>
				<listitem>
					<para>A <emphasis>repository library</emphasis> that manages the list of <code>RepositorySource</code> instances.
					    The library makes sure to inject the environments into each repository source, and it provides for each source
					    a configurable pool of connections.</para>
				</listitem>
				<listitem>
					<para>A <emphasis>configuration repository</emphasis> that contains descriptions of all of the repository sources
					    as well as any information those sources need.  Because this is a regular repository, this could be a simple 
					    repository with content loaded from an XML file (as in this example).  Or it could be a shared
					    central repository with information about all of the JBoss DNA processes across your company.</para>
				</listitem>
			</itemizedlist>
			With these components in place, we can then instantiate the <code>RepositoryService</code> and start it (using its
			<code>ServiceAdministrator</code>).  During startup, the service reads the configuration repository and loads any
			defined <code>RepositorySource</code> instances into the repository library, using the class loader factory 
			(available in the <code>ExecutionContext</code>) to obtain.
    </para>
		<para>Here's sample code that shows how to set up and start the repository service.  You can see something similar
			in the example application in the <code>startRepositories()</code> method of the <code>org.jboss.example.dna.repository.RepositoryClient</code> class.</para>
    <programlisting role="JAVA"><![CDATA[
  // Create the execution context that we'll use for the services. If we'd want to use JAAS, we'd 
  // create the context by supplying LoginContext, AccessControlContext, or even Subject with 
  // CallbackHandlers. But this example doesn't use JAAS in this example.
  ExecutionContext context = contextFactory.create();

  // Create the library for the RepositorySource instances ...
  RepositoryLibrary sources = new RepositoryLibrary(context);

  // Load into the source manager the repository source for the configuration repository ...
  InMemoryRepositorySource configSource = new InMemoryRepositorySource();
  configSource.setName("Configuration");
  sources.addSource(configSource);

  // Now instantiate the Repository Service ...
  RepositoryService service = new RepositoryService(sources, configSource.getName(), context);
  service.getAdministrator().start();
 ]]></programlisting>
		<para>After startup completes, the repositories are ready to be used.  The client application obtains the list of repositories
			and presents them to the user.  When the user selects one, the client application starts navigating that repository
			starting at its root node (e.g., the "/" path).  As you type a command to list the contents of the current node or to
			"change directories" to a different node, the client application obtains the information for the node using a simple
			procedure:
			<orderedlist>
				<listitem>
					<para>Get a connection to the repository.</para>
				</listitem>
				<listitem>
					<para>Using the connection, find the current node and read its properties and children, putting the information
						into a simple Java plain old Java object (POJO).</para>
				</listitem>
				<listitem>
					<para>Close the connection to the repository (in a finally block to ensure it always happens).</para>
				</listitem>
			</orderedlist>
		</para>
		<sect2 id="using_jcr_with_dna">
			<title>Using JCR to read repository</title>
			<para>If we want to perform these steps using JCR, a JCR <code>Session</code> represents our connection.
			  So after we create a <code>JcrRepository</code> instance pointing to our repository library, we can 
			  then login to obtain a JCR session:</para>
      <programlisting role="JAVA"><![CDATA[
	JcrRepository jcrRepository = new JcrRepository(context, sources);
	Session session = jcrRepository.login(sourceName);
 ]]></programlisting>
			<para>Now, the above code doesn't do any authentication; it essentially trusts the caller has the appropriate privileges.
				Normally, your application will need to authenticate the user, so let's look at how that's done.</para>
			<para>JBoss DNA uses the <ulink url="http://java.sun.com/j2se/1.5.0/docs/guide/security/jaas/tutorials/GeneralAcnOnly.html">Java 
				Authentication and Authorization Service (JAAS)</ulink>, making it possible to use any existing JAAS security provider.
				There are numerous JAAS providers, but one of the best open-source implementations is 
				<ulink url="http://www.jboss.org/jbosssecurity/">JBoss Security</ulink>, which can authenticate using LDAP, certificates,
				the operating system, and federated single-sign-on (among others).
			</para>
			<para>
				The JCR API defines a <code>Credentials</code> marker interface, an instance of which can be passed to the
			  <code>Session.login(...)</code> method.  Rather than provide a concrete implementation of this interface, JBoss DNA
			  allows you to pass any implementation of <code>Credentials</code> that also has one of the following methods:
			  <itemizedlist>
				  <listitem>
						<para><code>getLoginContext()</code> that returns a <code>javax.security.auth.login.LoginContext</code> instance.</para>
					</listitem>
				  <listitem>
						<para><code>getAccessControlContext()</code> that returns a <code>java.security.AccessControlContext</code> instance.</para>
					</listitem>
				</itemizedlist>
				This way, your application can obtain the JAAS <code>LoginContext</code> or <code>AccessControlContext</code> however it wants,
				and then merely passes that into DNA through the JCR <code>Credentials</code>.  No interfaces or classes specific to JBoss DNA are required.
			</para>
			<para>The following code shows how this is done, using an anonymous inner class for the <code>Credentials</code> implementation.</para>
      <programlisting role="JAVA"><![CDATA[
  CallbackHandler callbackHandler = // as needed by your app, according to JAAS
  final LoginContext loginContext = new LoginContext("MyAppContextName",callbackHandler);
  Credentials credentials = new Credentials() {
			public LoginContext getLoginContext() { return loginContext; }
  };
  JcrRepository jcrRepository = new JcrRepository(context, sources);
  Session session = jcrRepository.login(credentials, sourceName);
 ]]></programlisting>
			<para>Once you have a JCR session, you can then use it to find the node of interest and access the necessary information. All of this
				code will use only the JCR API - there's nothing specific to JBoss DNA's implementation.  And remember, when you're finished with
				the session, be sure to logout (usually in a <code>finally</code> block):</para>
 <programlisting role="JAVA"><![CDATA[
  if (session != null) session.logout();
 ]]></programlisting>
			<para>Like many people recommend with JCR, you can create either long-lived or short-lived JCR <code>Session</code>s.  The
			  JBoss DNA implementation of JCR was designed to efficiently do either.</para>
		</sect2>	
		<!--
		<sect2 id="using_dna_repositories_with_dna_api">
			<title>Using JBoss DNA's API to read repository</title>
			<para>Although we recommend using JCR, JBoss DNA has an internal command-based API that completely side-steps JCR and provides
				very simple graph-based operations.  For more information, see the <code>RepositoryClient</code> class in the example.</para>
			<note>
				<para>This API is likely to undergo changes in the next few releases, and using it at this time is not suggested.</para>
			</note>
		</sect2>
		-->
	</sect1>
	<sect1 id="shutting_down_repository_service">
		<title>Shutting down the Repository Service</title>
		<para>In the first part of this chapter, we saw how to instantiate, configure, and start the <code>RepositoryService</code>.
		  We then saw how to use JCR to access the repository service by creating JCR <code>Session</code>s, and how to log out of those
		  sessions when no longer needed.</para>
		<para>In this short section we'll see how to shut down the <code>RepositoryService</code> and <code>RepositoryLibrary</code>
		  when you're finished with all of the repositories.  It's a simple but important step, since this closes all outstanding 
		  connections that may be sitting unused in the library's connection pools.</para>
		<para>Shutting down these components is very straightforward: get the <code>ServiceAdministrator</code> on each, and call <code>shutdown()</code>.</para>
		<programlisting role="JAVA"><![CDATA[
  // Shut down the repository service ...
  repositoryService.getAdministrator().shutdown();

  // Shut down the manager of the RepositorySource instances, waiting until all connections are closed
  sources.getAdministrator().shutdown();
  sources.getAdministrator().awaitTermination(1, TimeUnit.SECONDS);
 ]]></programlisting>
		<para>The <code>shutdown()</code> method attempts to close all open and unused resources (such as open and unused connections in the pool).
		  No more connections can be created, and any connections that are currently in use are not closed but allowed to be used and closed normally.
		  When the last connection is used, the service then transitions to a <emphasis>terminated</emphasis> state, which you can wait for using
		  the <code>awaitTermination(int,TimeUnit)</code> method.</para>
		<para>If you want to shutdown the services immediately, then you could call <code>shutdownNow()</code>, which blocks while it attempts to immediately
		  close all connections - <emphasis>even those currently in use</emphasis>.  So, while you generally want to use <code>shutdown()</code>,
		  it is good to be aware that this <code>shutdownNow()</code> method does exist.</para>
	</sect1>
	<sect1 id="example_repository_application_review">
		<title>Reviewing the example repository application</title>
		<para>Recall that the example repository application consists of a client application that sets up a repository service and the
			repositories defined in a configuration repository, allowing the user to pick a repository and interactively navigate
			the selected repository.  Several repositories are set up, including several in-memory repositories and one federated repository
			that dynamically federates the content from the other repositories.</para>
		<para>
      The example is comprised of 2 classes and 1 interface, located in the <code>src/main/java</code> directory:</para>
    <programlisting><![CDATA[
  org/jboss/example/dna/repositories/ConsoleInput.java
                                    /RepositoryClient.java
                                    /UserInterface.java
  ]]></programlisting>
		<para><code>RepositoryClient</code> is the class that contains the main application. It uses an instance of the
      <code>UserInterface</code> interface to  methods that will be called at runtime to obtain information about the
      files that are imported into the in-memory repositories and the JAAS <code>CallbackHandler</code> implementation
      that will be used by JAAS to prompt the user for authentication information.  Finally, the <code>ConsoleInput</code>
			is an implementation of this that creates a text user interface,	allowing the user to operate the client from the command-line.  
			We can easily create a graphical implementation of <code>UserInterface</code> at a later date, or we can also create a mock 
			implementation for testing purposes that simulates a user entering data. This allows us to check the behavior of the client 
			automatically using conventional JUnit test cases, as demonstrated by the code in the <code>src/test/java</code> directory:</para>
    <programlisting><![CDATA[
  org/jboss/example/dna/sequencers/RepositoryClientTest.java
                                  /RepositoryClientUsingJcrTest.java
  ]]></programlisting>
		<para>
			The code we presented earlier in this chapter represent the bulk of the JBoss DNA and JCR-specific code used in the
			<code>RepositoryClient</code>, so we won't cover it in any more detail here.  Please refer to the sample client code
			if you want to see more.
		</para>
	</sect1>
	<sect1 id="using_dna_repositories_review">
		<title>Summarizing what we just did</title>
		<para>In this chapter we covered the different JBoss DNA components used for accessing repositories through JCR, including
			repositories that federate their content from the content of other repositories.  Specifically, we described how the
			<code>RepositoryService</code> and <code>JcrRepository</code> can be configured and used.
		</para>
	</sect1>
</chapter>
	
