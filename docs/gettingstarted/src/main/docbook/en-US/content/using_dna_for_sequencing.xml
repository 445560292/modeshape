<?xml version="1.0" encoding="UTF-8"?>
<!--
  ~ JBoss DNA (http://www.jboss.org/dna)
  ~
  ~ See the COPYRIGHT.txt file distributed with this work for information
  ~ regarding copyright ownership.  Some portions may be licensed
  ~ to Red Hat, Inc. under one or more contributor license agreements.
  ~ See the AUTHORS.txt file in the distribution for a full listing of 
  ~ individual contributors.
  ~
  ~ JBoss DNA is free software. Unless otherwise indicated, all code in JBoss DNA
  ~ is licensed to you under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ JBoss DNA is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  ~ or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  ~ for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public License
  ~ along with this distribution; if not, write to:
  ~ Free Software Foundation, Inc.
  ~ 51 Franklin Street, Fifth Floor
  ~ Boston, MA  02110-1301  USA
  -->
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter id="using_dna_for_sequencing">
	<title>Using JBoss DNA for Sequencing</title>
	<para>As we've mentioned before, JBoss DNA is able to work with existing JCR repositories.  Your client applications
  	make changes to the information in those repositories, and JBoss DNA automatically uses its sequencers to extract
  	additional information from the uploaded files.</para>
	<note>
		<para>Configuring JBoss DNA services is a bit more manual than is ideal. As you'll see, JBoss DNA uses dependency
      injection to allow a great deal of flexibility in how it can be configured and customized. But this flexibility
      makes it more difficult for you to use.  We understand this, and will soon provide a much easier way to set up 
			and manage JBoss DNA.  Current plans are to use the <ulink url="http://www.jboss.org/jbossmc">JBoss Microcontainer</ulink>
			along with a configuration repository.</para>
	</note>
	<sect1 id="sequencing_service">
		<title>Configuring the Sequencing Service</title>
		<para>The JBoss DNA <emphasis>sequencing service</emphasis> is the component that manages the <emphasis>sequencers</emphasis>, 
			reacting to changes in JCR repositories and then running the appropriate sequencers.
      This involves processing the changes on a node, determining which (if any) sequencers should be run on that node,
      and for each sequencer constructing the execution environment, calling the sequencer, and saving the information
      generated by the sequencer.</para>
		<para>To set up the sequencing service, an instance is created, and dependent components are injected into
      the object.  This includes among other things:
			<itemizedlist>
				<listitem>
					<para>An <emphasis>execution context</emphasis> that defines the context in which the service runs, including
			        a factory for JCR sessions given names of the repository and workspace.  This factory must be configured,
			        and is how JBoss DNA knows about your JCR repositories and how to connect to them.  More on this a bit later.</para>
				</listitem>
				<listitem>
					<para>An <code>java.util.concurrent.ExecutorService</code> used to execute the sequencing activites.  If none
			        is supplied, a new single-threaded executor is created by calling <code>Executors.newSingleThreadExecutor()</code>.
			        (This can easily be changed by subclassing and overriding the <code>SequencerService.createDefaultExecutorService()</code> method.)</para>
				</listitem>
				<listitem>
					<para>Filters for sequencers and events.  By default, all sequencers are considered for "node added", "property added"
			        and "property changed" events.</para>
				</listitem>
			</itemizedlist>
    </para>
		<para>As mentioned above, the <code>JcrExecutionContext</code> provides access to a <code>SessionFactory</code> that is used
      by JBoss DNA to establish sessions to your JCR repositories.  Two implementations are available:
			<itemizedlist>
				<listitem>
					<para>The <code>JndiSessionFactory</code> looks up JCR <code>Repository</code> instances in JNDI using
			          names that are supplied when creating sessions.  This implementation also has methods to set the
			          JCR <code>Credentials</code> for a given workspace name.</para>
				</listitem>
				<listitem>
					<para>The <code>SimpleSessionFactory</code> has methods to register the JCR <code>Repository</code> instances
			          with names, as well as methods to set the JCR <code>Credentials</code> for a given workspace name.</para>
				</listitem>
			</itemizedlist>
      You can use the <code>SimpleExecutionContext</code> implementation of <code>ExecutionContext</code> and supply
      a <code>SessionFactory</code> instance, or you can provide your own implementation.</para>
		<para>Here's an example of how to instantiate and configure the SequencingService:</para>
    <programlisting role="JAVA"><![CDATA[
SimpleSessionFactory sessionFactory = new SimpleSessionFactory();
sessionFactory.registerRepository("Repository", this.repository);
Credentials credentials = new SimpleCredentials("jsmith", "secret".toCharArray());
sessionFactory.registerCredentials("Repository/Workspace1", credentials);
JcrExecutionContext context = new JcrExecutionContext(sessionFactory,"Repository/Workspace1");

// Create the sequencing service, passing in the execution context ...
SequencingService sequencingService = new SequencingService();
sequencingService.setExecutionContext(context);
  ]]></programlisting>
		<para>After the sequencing service is created and configured, it must be started.  The SequencingService
      has an <emphasis>administration object</emphasis> (that is an instance of <code>ServiceAdministrator</code>)
      with <code>start()</code>, <code>pause()</code>, and <code>shutdown()</code> methods.  The latter method will 
      close the queue for sequencing, but will allow sequencing operations already running to complete normally.
      To wait until all sequencing operations have completed, simply call the <code>awaitTermination</code> method
      and pass it the maximum amount of time you want to wait.</para>
		<programlisting role="JAVA"><![CDATA[sequencingService.getAdministrator().start();
]]></programlisting>
		<para>The sequencing service must also be configured with the sequencers that it will use.  This is done using the
      <code>addSequencer(SequencerConfig)</code> method and passing a <code>SequencerConfig</code> instance that
      you create.  Here's the code that defines 3 sequencer configurations: 1 that places image metadata into
      "<code><![CDATA[/images/<filename>]]></code>", another that places MP3 metadata into "<code><![CDATA[/mp3s/<filename>]]></code>",
      and a third that places a structure that represents the classes, methods, and attributes found within Java source into 
      "<code><![CDATA[/java/<filename>]]></code>".</para>
    <programlisting role="JAVA"><![CDATA[
String name = "Image Sequencer";
String desc = "Sequences image files to extract the characteristics of the image";
String classname = "org.jboss.dna.sequencer.image.ImageMetadataSequencer";
String[] classpath = null; // Use the current classpath
String[] pathExpressions = {"//(*.(jpg|jpeg|gif|bmp|pcx|png)[*])/jcr:content[@jcr:data] => /images/$1"};
SequencerConfig imageSequencerConfig = new SequencerConfig(name, desc, classname, 
                                                           classpath, pathExpressions);
sequencingService.addSequencer(imageSequencerConfig);

name = "MP3 Sequencer";
desc = "Sequences MP3 files to extract the ID3 tags from the audio file";
classname = "org.jboss.dna.sequencer.mp3.Mp3MetadataSequencer";
pathExpressions = {"//(*.mp3[*])/jcr:content[@jcr:data] =&gt; /mp3s/$1"};
SequencerConfig mp3SequencerConfig = new SequencerConfig(name, desc, classname, 
                                                         classpath, pathExpressions);
sequencingService.addSequencer(mp3SequencerConfig);

name = "Java Sequencer";
desc = "Sequences java files to extract the characteristics of the Java source";
classname = "org.jboss.dna.sequencer.java.JavaMetadataSequencer";
pathExpressions = {"//(*.java[*])/jcr:content[@jcr:data] => /java/$1"};
SequencerConfig javaSequencerConfig = new SequencerConfig(name, desc, classname, 
                                                          classpath, pathExpressions);
this.sequencingService.addSequencer(javaSequencerConfig);
  ]]></programlisting>
    <para>Each configuration defines several things, including the name, description, and sequencer implementation class.
	    The configuration also defines the classpath information, which can be passed to the <code>ExecutionContext</code> to get
	    a Java classloader with which the sequencer class can be loaded.  (If no classpath information is provided, as is done
	    in the code above, the application class loader is used.)  The configuration also specifies the path expressions that
	    identify the nodes that should be sequenced with the sequencer and where to store the output generated by the sequencer.
	    Path expressions are pretty straightforward but are quite powerful, so before we go any further with the example,
	    let's dive into path expressions in more detail.</para>
		<sect2 id="path_expressions">
			<title>Path Expressions</title>
			<para>Path expressions consist of two parts: a selection criteria (or an input path) and an output path:</para>
	    <programlisting><![CDATA[  inputPath => outputPath ]]></programlisting>
			<para>The <emphasis>inputPath</emphasis> part defines an expression for the path of a node that is to be sequenced.
			  Input paths consist of '<code>/</code>' separated segments, where each segment represents a pattern for a single node's
			  name (including the same-name-sibling indexes) and '<code>@</code>' signifies a property name.</para>
			<para>Let's first look at some simple examples:</para>
			<table frame='all'>
				<title>Simple Input Path Examples</title>
				<tgroup cols='2' align='left' colsep='1' rowsep='1'>
		      <colspec colname='c1' colwidth="1*"/>
		      <colspec colname='c2' colwidth="1*"/>
					<thead>
						<row>
				  		<entry>Input Path</entry>
				  		<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row><entry>/a/b</entry><entry>Match node "<code>b</code>" that is a child of the top level node "<code>a</code>". Neither node
						     may have any same-name-sibilings.</entry></row>
						<row><entry>/a/*</entry><entry>Match any child node of the top level node "<code>a</code>".</entry></row>
						<row><entry>/a/*.txt</entry><entry>Match any child node of the top level node "<code>a</code>" that also has a name ending in "<code>.txt</code>".</entry></row>
						<row><entry>/a/*.txt</entry><entry>Match any child node of the top level node "<code>a</code>" that also has a name ending in "<code>.txt</code>".</entry></row>
						<row><entry>/a/b@c</entry><entry>Match the property "<code>c</code>" of node "<code>/a/b</code>".</entry></row>
						<row><entry>/a/b[2]</entry><entry>The second child named "<code>b</code>" below the top level node "<code>a</code>".</entry></row>
						<row><entry>/a/b[2,3,4]</entry><entry>The second, third or fourth child named "<code>b</code>" below the top level node "<code>a</code>".</entry></row>
						<row><entry>/a/b[*]</entry><entry>Any (and every) child named "<code>b</code>" below the top level node "<code>a</code>".</entry></row>
						<row><entry>//a/b</entry><entry>Any node named "<code>b</code>" that exists below a node named "<code>a</code>", regardless 
						     of where node "<code>a</code>" occurs.  Again, neither node may have any same-name-sibilings.</entry></row>
					</tbody>
				</tgroup>
			</table>
			<para>With these simple examples, you can probably discern the most important rules.  First, the '<code>*</code>' is a wildcard character
			  that matches any character or sequence of characters in a node's name (or index if appearing in between square brackets), and
			  can be used in conjunction with other characters (e.g., "<code>*.txt</code>").</para>
			<para>Second, square brackets (i.e., '<code>[</code>' and '<code>]</code>') are used to match a node's same-name-sibiling index.
			  You can put a single non-negative number or a comma-separated list of non-negative numbers.  Use '0' to match a node that has no
			  same-name-sibilings, or any positive number to match the specific same-name-sibling.</para>
			<para>Third, combining two delimiters (e.g., "<code>//</code>") matches any sequence of nodes, regardless of what their names are 
			  or how many nodes.  Often used with other patterns to identify nodes at any level matching other patterns. 
				Three or more sequential slash characters are treated as two.</para>
			<para>Many input paths can be created using just these simple rules.  However, input paths can be more complicated.  Here are some
				more examples:</para>
			<table frame='all'>
				<title>More Complex Input Path Examples</title>
				<tgroup cols='2' align='left' colsep='1' rowsep='1'>
		      <colspec colname='c1' colwidth="1*"/>
		      <colspec colname='c2' colwidth="1*"/>
					<thead>
						<row>
				  		<entry>Input Path</entry>
				  		<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row><entry>/a/(b|c|d)</entry><entry>Match children of the top level node "<code>a</code>" that are named "<code>a</code>", 
								 "<code>b</code>" or "<code>c</code>". None of the nodes may have same-name-sibling indexes.</entry></row>
						<row><entry>/a/b[c/d]</entry><entry>Match node "<code>b</code>" child of the top level node "<code>a</code>", when node
						     "<code>b</code>" has a child named "<code>c</code>", and "<code>c</code>" has a child named "<code>d</code>".
								 Node "<code>b</code>" is the selected node, while nodes "<code>b</code>" and "<code>b</code>" are used as criteria but are not
								 selected.</entry></row>
						<row><entry>/a(/(b|c|d|)/e)[f/g/@something]</entry><entry>Match node "<code>/a/b/e</code>", "<code>/a/c/e</code>", "<code>/a/d/e</code>",
						     or "<code>/a/e</code>" when they also have a child "<code>f</code>" that itself has a child "<code>g</code>" with property
						     "<code>something</code>". None of the nodes may have same-name-sibling indexes.</entry></row>
					</tbody>
				</tgroup>
			</table>
			<para>These examples show a few more advanced rules.  Parentheses (i.e., '<code>(</code>' and '<code>)</code>') can be used
			  to define a set of options for names, as shown in the first and third rules.  Whatever part of the selected node's path
			  appears between the parentheses is captured for use within the output path.  Thus, the first input path in the previous table
			  would match node "<code>/a/b</code>", and "b" would be captured and could be used within the output path using "<code>$1</code>",
			  where the number used in the output path identifies the parentheses.</para>
			<para>Square brackets can also be used to specify criteria on a node's properties or children.  Whatever appears in between the square
				brackets does not appear in the selected node.</para>
		  <para>Let's go back to the previous code fragment and look at the first path expression:</para>
		  <programlisting><![CDATA[  //(*.(jpg|jpeg|gif|bmp|pcx|png)[*])/jcr:content[@jcr:data] => /images/$1 ]]></programlisting>
		  <para>This matches a node named "<code>jcr:content</code>" with property "<code>jcr:data</code>" but no siblings with the same name,
		    and that is a child of a node whose name ends with "<code>.jpg</code>", "<code>.jpeg</code>", "<code>.gif</code>", "<code>.bmp</code>", "<code>.pcx</code>", 
		    or  "<code>.png</code>" that may have any same-name-sibling index.  These nodes can appear at any level in the repository.
			  Note how the input path capture the filename (the segment containing the file extension), including any same-name-sibling index.
			  This filename is then used in the output path, which is where the sequenced content is placed.</para>
		</sect2>
		<sect2 id="path_expressions_in_example">
			<title>Path Expressions Used in the Example</title>
			<para>Now that we've covered path expressions, let's go back to the three sequencer configuration in the example.
				Here they are again, with a description of what each path means:</para>
			<table frame='all'>
				<title>Path Expressions for the 3 Sequencers</title>
				<tgroup cols='3' align='left' colsep='1' rowsep='1'>
		      <colspec colname='c1' colwidth="1*"/>
		      <colspec colname='c2' colwidth="1*"/>
		      <colspec colname='c2' colwidth="1*"/>
					<thead>
						<row>
				  		<entry>Input Path</entry>
				  		<entry>Output Path</entry>
				  		<entry>Description</entry>
						</row>
					</thead>
					<tbody>
						<row>
							<entry><![CDATA[//(*.(jpg|jpeg|gif|bmp|pcx|png)[*])/jcr:content[@jcr:data]]]></entry>
							<entry><![CDATA[/images/$1]]></entry>
							<entry>Any node with a name ending in "<code>.jpg</code>", "<code>.jpeg</code>", "<code>.gif</code>", "<code>.bmp</code>", 
							  "<code>.pcx</code>", or "<code>.png</code>", whether or not it has a same-name-sibling index, but that has a child named 
								"<code>jcr:content</code>" with "<code>jcr:data</code>" property.  The node name representing the filename (including any
								same-name-sibling index) is captured, and used to place the output in "<code><![CDATA[/images/<filename>]]></code>".</entry>
						</row>
						<row>
							<entry><![CDATA[//(*.mp3[*])/jcr:content[@jcr:data]]]></entry>
							<entry><![CDATA[/mp3s/$1]]></entry>
							<entry>Any node with a name ending in "<code>.mp3</code>", whether or not it has a same-name-sibling index, but that has a child named 
								"<code>jcr:content</code>" with "<code>jcr:data</code>" property.  The node name representing the filename (including any
								same-name-sibling index) is captured, and used to place the output in "<code><![CDATA[/mp3s/<filename>]]></code>".</entry>
						</row>
						<row>
							<entry><![CDATA[//(*.java[*])/jcr:content[@jcr:data]]]></entry>
							<entry><![CDATA[/java/$1]]></entry>
							<entry>Any node with a name ending in "<code>.java</code>", whether or not it has a same-name-sibling index, but that has a child named 
								"<code>jcr:content</code>" with "<code>jcr:data</code>" property.  The node name representing the filename (including any
								same-name-sibling index) is captured, and used to place the output in "<code><![CDATA[/java/<filename>]]></code>".</entry>
						</row>
					</tbody>
				</tgroup>
			</table>
			<para>After these sequencer configurations are defined and added to the <code>SequencingService</code>,
				the service is now ready to start reacting to changes in the repository and automatically looking for nodes to sequence.  
				But we first need to wire the service into the repository to receive those change events.
	      This is accomplished using the <code>ObservationService</code>
	      described in the <link linkend="observation_service">next section</link>.</para>
		</sect2>
	</sect1>
	<sect1 id="observation_service">
		<title>Configuring the Observation Service</title>
		<para>The JBoss DNA <code>ObservationService</code> is responsible for listening to one or more JCR repositories
	    and multiplexing the events to its listeners.  Unlike JCR events, this framework embeds in the events the
	    name of the repository and workspace that can be passed to a <code>SessionFactory</code> to obtain a session
	    to the repository in which the change occurred.  This simple design makes it very easy for JBoss DNA to
	    concurrently work with multiple JCR repositories.</para>
		<para>Configuring an observation service is pretty easy, especially if you reuse the same <code>SessionFactory</code>
	    supplied to the sequencing service.  Here's an example:</para>
    <programlisting role="JAVA"><![CDATA[
  this.observationService = new ObservationService(sessionFactory);
  this.observationService.getAdministrator().start();
  ]]></programlisting>
		<note>
			<para>Both <code>ObservationService</code> and <code>SequencingService</code> implement
    		<code>AdministeredService</code>, which has a <code>ServiceAdministrator</code> used to start, pause, and shutdown the
    		service.  In other words, the lifecycle of the services are managed in the same way.</para>
		</note>
		<para>After the observation service is started, listeners can be added.  The <code>SequencingService</code> implements the required
    interface, and so it may be registered directly:</para>
    <programlisting role="JAVA"><![CDATA[
  observationService.addListener(sequencingService);
  ]]></programlisting>
		<para>Finally, the observation service must be wired to monitor one of your JCR repositories.  This is done with
    	one of the <code>monitor(...)</code> methods:</para>
    <programlisting role="JAVA"><![CDATA[
  int eventTypes = Event.NODE_ADDED | Event.PROPERTY_ADDED | Event.PROPERTY_CHANGED;
  observationService.monitor("Main Repository/Workspace1", eventTypes);
  ]]></programlisting>
		<para>At this point, the observation service is listening to a JCR repository and forwarding the appropriate events
    	to the sequencing service, which will asynchronously process the changes and sequence the information added to or changed in the repository.
    </para>
	</sect1>
	<sect1 id="shutting_down">
		<title>Shutting down JBoss DNA services</title>
		<para>The JBoss DNA services are utilizing resources and threads that must be released before your application is ready to shut down.
    	The safe way to do this is to simply obtain the <code>ServiceAdministrator</code> for each service (via the <code>getServiceAdministrator()</code> method)
    	and call <code>shutdown()</code>.  As previously mentioned, the shutdown method will simply prevent new work from being processed
    	and will not wait for existing work to be completed.  If you want to wait until the service completes all its work, you must wait
    	until the service terminates.  Here's an example that shows how this is done:</para>
    <programlisting role="JAVA"><![CDATA[
// Shut down the service and wait until it's all shut down ...
sequencingService.getAdministrator().shutdown();
sequencingService.getAdministrator().awaitTermination(5, TimeUnit.SECONDS);

// Shut down the observation service ...
observationService.getAdministrator().shutdown();
observationService.getAdministrator().awaitTermination(5, TimeUnit.SECONDS);
  ]]></programlisting>
		<para>At this point, we've covered how to configure and use the JBoss DNA services in your application.
    	The next chapter goes back to the <link linkend="downloading_and_running">sample application</link> to show how all 
			these pieces fit together.</para>
	</sect1>
	<sect1 id="example_application_review">
		<title>Reviewing the example application</title>
		<para>Recall that the example application consists of a client application that sets up an in-memory JCR repository and
      that allows a user to upload files into that repository. The client also sets up the DNA services with an image sequencer so
      that if any of the uploaded files are PNG, JPEG, GIF, BMP or other images, DNA will automatically extract the image's
      metadata (e.g., image format, physical size, pixel density, etc.) and store that in the repository.  Or, if the client uploads
      MP3 audio files, the title, author, album, year, and comment are extracted from the audio file and stored in the repository.</para>
		<para>
      The example is comprised of 5 classes and 1 interface, located in the <code>src/main/java</code> directory:</para>
    <programlisting><![CDATA[
  org/jboss/example/dna/sequencers/ConsoleInput.java
                                  /ContentInfo.java
                                  /JavaInfo.java
                                  /MediaInfo.java
                                  /SequencingClient.java
                                  /UserInterface.java
  ]]></programlisting>
		<para><code>SequencingClient</code> is the class that contains the main application.  <code>ContentInfo</code> is a simple class
		  that encapsulate metadata generated by the sequencers and accessed by this example application, and there are two subclasses: 
		  <code>MediaInfo</code> encapsulates metadata about media (image and MP3) files, while <code>JavaInfo</code> is a subclass
		  encapsulating information about a Java class.  The client accesses the content from the repository and represent the
		  information using instances of <code>ContentInfo</code> (and its subclasses) and then passing them to the <code>UserInterface</code>.
      <code>UserInterface</code> is an interface with methods that will be called at runtime to 
			request data from the user.  <code>ConsoleInput</code> is an implementation of this that creates a text user interface, 
			allowing the user to operate the client from the command-line.  We can easily create a graphical implementation of
      <code>UserInterface</code> at a later date. We can also create a mock implementation for testing purposes that simulates 
			a user entering data. This allows us to check the behavior of the client automatically using conventional JUnit test cases, 
			as demonstrated by the code in the <code>src/test/java</code> directory:</para>
    <programlisting><![CDATA[
  org/jboss/example/dna/sequencers/SequencingClientTest.java
                                  /MockUserInterface.java
  ]]></programlisting>
		<para>If we look at the <code>SequencingClient</code> code, there are a handful of methods that encapsulate the various activities.</para>
		<note>
			<para>Some of the code samples included in this book have had some of the error handling and comments removed so that
				the samples are more readable and concise.</para>
		</note>
		<para>The <code>startRepository()</code> method starts up an in-memory Jackrabbit JCR repository. The bulk of this method is simply 
			gathering and passing the information required by Jackrabbit. Because Jackrabbit's <code>TransientRepository</code>
      implementation shuts down after the last session is closed, the application maintains a session to ensure that the
      repository remains open throughout the application's lifetime. And finally, the node type needed by the image sequencer is
      registered with Jackrabbit.</para>
		<programlisting role="JAVA"><![CDATA[
public void startRepository() throws Exception {
    if (this.repository == null) {
        try {

            // Load the Jackrabbit configuration ...
            File configFile = new File(this.jackrabbitConfigPath);
            String pathToConfig = configFile.getAbsolutePath();

            // Find the directory where the Jackrabbit repository data will be stored ...
            File workingDirectory = new File(this.workingDirectory);
            String workingDirectoryPath = workingDirectory.getAbsolutePath();

            // Get the Jackrabbit custom node definition (CND) file ...
            URL cndFile = Thread.currentThread().getContextClassLoader().getResource("jackrabbitNodeTypes.cnd");

            // Create the Jackrabbit repository instance and establish a session to keep the repository alive ...
            this.repository = new TransientRepository(pathToConfig, workingDirectoryPath);
            if (this.username != null) {
                Credentials credentials = new SimpleCredentials(this.username, this.password);
                this.keepAliveSession = this.repository.login(credentials, this.workspaceName);
            } else {
                this.keepAliveSession = this.repository.login();
            }

            try {
                // Register the node types (only valid the first time) ...
                Workspace workspace = this.keepAliveSession.getWorkspace();
                JackrabbitNodeTypeManager mgr = (JackrabbitNodeTypeManager)workspace.getNodeTypeManager();
                mgr.registerNodeTypes(cndFile.openStream(), JackrabbitNodeTypeManager.TEXT_X_JCR_CND);
            } catch (RepositoryException e) {
                if (!e.getMessage().contains("already exists")) throw e;
            }

        } catch (Exception e) {
            this.repository = null;
            this.keepAliveSession = null;
            throw e;
        }
    }
}
  ]]></programlisting>
		<para>As you can see, this method really has nothing to do with JBoss DNA, other than setting up a JCR repository that JBoss
      DNA will use.</para>
		<para>The <code>shutdownRepository()</code> method shuts down the Jackrabbit transient repository by closing the "keep-alive session". 
			Again, this method really does nothing specifically with JBoss DNA, but is needed to manage the JCR repository that JBoss DNA uses.</para>
    <programlisting role="JAVA"><![CDATA[
public void shutdownRepository() throws Exception {
    if (this.repository != null) {
        try {
            this.keepAliveSession.logout();
        } finally {
            this.repository = null;
            this.keepAliveSession = null;
        }
    }
}
  ]]></programlisting>
		<para>The <code>startDnaServices()</code> method first starts the JCR repository (if it was not already started), and proceeds 
			to create and configure the <code>SequencingService</code> as described <link linkend="sequencing_service">earlier</link>.
      This involes setting up the <code>SessionFactory</code> and <code>ExecutionContext</code>, creating the
      <code>SequencingService</code> instance, and configuring the image sequencer. The method then continues by setting up the
      <code>ObservationService</code> as described <link linkend="observation_service">earlier</link> and starting the service.</para>
		<programlisting role="JAVA"><![CDATA[
public void startDnaServices() throws Exception {
    if (this.repository == null) this.startRepository();
    if (this.sequencingService == null) {

        SimpleSessionFactory sessionFactory = new SimpleSessionFactory();
        sessionFactory.registerRepository(this.repositoryName, this.repository);
        if (this.username != null) {
            Credentials credentials = new SimpleCredentials(this.username, this.password);
            sessionFactory.registerCredentials(this.repositoryName + "/" + this.workspaceName, credentials);
        }
        this.executionContext = new JcrExecutionContext(sessionFactory, repositoryWorkspaceName);

        // Create the sequencing service, passing in the execution context ...
        this.sequencingService = new SequencingService();
        this.sequencingService.setExecutionContext(executionContext);

        // Configure the sequencers.
        String name = "Image Sequencer";
        String desc = "Sequences image files to extract the characteristics of the image";
        String classname = "org.jboss.dna.sequencer.images.ImageMetadataSequencer";
        String[] classpath = null; // Use the current classpath
        String[] pathExpressions = {"//(*.(jpg|jpeg|gif|bmp|pcx|png|iff|ras|pbm|pgm|ppm|psd))[*]/jcr:content[@jcr:data] => /images/$1"};
        SequencerConfig imageSequencerConfig = new SequencerConfig(name, desc, classname, classpath, pathExpressions);
        this.sequencingService.addSequencer(imageSequencerConfig);

        // Set up the MP3 sequencer ...
        name = "Mp3 Sequencer";
        desc = "Sequences mp3 files to extract the id3 tags of the audio file";
        classname = "org.jboss.dna.sequencer.mp3.Mp3MetadataSequencer";
        pathExpressions = {"//(*.mp3)[*]/jcr:content[@jcr:data] =&gt; /mp3s/$1"};
        SequencerConfig mp3SequencerConfig = new SequencerConfig(name, desc, classname, classpath, pathExpressions);
        this.sequencingService.addSequencer(mp3SequencerConfig);

				name = "Java Sequencer";
				desc = "Sequences java files to extract the characteristics of the Java source";
				classname = "org.jboss.dna.sequencer.java.JavaMetadataSequencer";
				pathExpressions = {"//(*.java[*])/jcr:content[@jcr:data] => /java/$1"};
				SequencerConfig javaSequencerConfig = new SequencerConfig(name, desc, classname,classpath, pathExpressions);
				this.sequencingService.addSequencer(javaSequencerConfig);

        // Use the DNA observation service to listen to the JCR repository (or multiple ones), and
        // then register the sequencing service as a listener to this observation service...
        this.observationService = new ObservationService(this.executionContext.getSessionFactory());
        this.observationService.getAdministrator().start();
        this.observationService.addListener(this.sequencingService);
        this.observationService.monitor(this.repositoryName + "/" + this.workspaceName, Event.NODE_ADDED | Event.PROPERTY_ADDED | Event.PROPERTY_CHANGED);
    }
    // Start up the sequencing service ...
    this.sequencingService.getAdministrator().start();
}
  ]]></programlisting>
		<para>The <code>shutdownDnaServices()</code> method is pretty straightforward: it just calls shutdown on each of the services
			and waits until they terminate.</para>
    <programlisting role="JAVA"><![CDATA[
public void shutdownDnaServices() throws Exception {
    if (this.sequencingService == null) return;

    // Shut down the service and wait until it's all shut down ...
    this.sequencingService.getAdministrator().shutdown();
    this.sequencingService.getAdministrator().awaitTermination(5, TimeUnit.SECONDS);

    // Shut down the observation service ...
    this.observationService.getAdministrator().shutdown();
    this.observationService.getAdministrator().awaitTermination(5, TimeUnit.SECONDS);
}
  ]]></programlisting>
		<para>None of the other methods really do anything with JBoss DNA <emphasis>per se</emphasis>. Instead, they merely work with the repository
      using the JCR API.</para>
		<para>The <code>main</code> method of the <code>SequencingClient</code> class creates a <code>SequencingClient</code> instance,
      and passes a new <code>ConsoleInput</code> instance:</para>
    <programlisting role="JAVA"><![CDATA[
public static void main( String[] args ) throws Exception {
    SequencingClient client = new SequencingClient();
    client.setRepositoryInformation("repo", "default", "jsmith", "secret".toCharArray());
    client.setUserInterface(new ConsoleInput(client));
}
  ]]></programlisting>
		<para>If we look at the <code>ConsoleInput</code> constructor, it starts the repository, the DNA services, and a thread 
			for the user interface. At this point, the constructor returns, but the main application continues under the user interface thread.  
			When the user requests to quit, the user interface thread also shuts down the DNA services and JCR repository.</para>
    <programlisting role="JAVA"><![CDATA[
public ConsoleInput( SequencerClient client ) {
  try {
      client.startRepository();
      client.startDnaServices();
  
      System.out.println(getMenu());
      Thread eventThread = new Thread(new Runnable() {
          private boolean quit = false;
          public void run() {
              try {
                  while (!quit) {
                      // Display the prompt and process the requested operation ...
                  }
              } finally {
                  try {
                      // Terminate ...
                      client.shutdownDnaServices();
                      client.shutdownRepository();
                  } catch (Exception err) {
                      System.out.println("Error shutting down sequencing service and repository: " 
                                         + err.getLocalizedMessage());
                      err.printStackTrace(System.err);
                  }
              }
          }
      });
      eventThread.start();
  } catch (Exception err) {
      System.out.println("Error: " + err.getLocalizedMessage());
      err.printStackTrace(System.err);
  }
}
  ]]></programlisting>
		<para>At this point, we've reviewed all of the interesting code in the example application.  However, feel free
    to play with the application, trying different things.</para>
	</sect1>
	<sect1 id="using_dna_review">
		<title>Summarizing what we just did</title>
		<para>In this chapter we covered the different JBoss DNA components used for automatically sequencing a variety of
			types of information, and how those components can be used in your application.
      Specifically, we described how the <code>SequencingService</code> and <code>ObservationService</code> can 
      be configured and used.  And we ended the chapter by reviewing the example application, which not only uses
      JBoss DNA, but also the repository via the JCR API.</para>
	</sect1>
</chapter>
